using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GenBlocks.Generators;

[Generator]
public class EnumerationConstantsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes that inherit from Enumeration<T>
        var enumerationDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsEnumerationClass(s),
                transform: static (ctx, _) => GetEnumerationClass(ctx))
            .Where(static m => m is not null);

        // Generate the source
        context.RegisterSourceOutput(enumerationDeclarations,
            static (spc, source) => Execute(source!, spc));
    }

    static bool IsEnumerationClass(SyntaxNode node)
        => node is ClassDeclarationSyntax { BaseList: not null };

    static ClassDeclarationSyntax? GetEnumerationClass(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        
        // Check if it inherits from Enumeration<T>
        if (classDeclarationSyntax.BaseList != null)
        {
            foreach (var baseType in classDeclarationSyntax.BaseList.Types)
            {
                var baseTypeName = baseType.Type.ToString();
                if (baseTypeName.StartsWith("Enumeration<") || baseTypeName == "Enumeration")
                {
                    // Check if it has the GenerateConstants attribute
                    foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
                    {
                        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
                        {
                            if (attributeSyntax.Name.ToString() == "GenerateConstants")
                            {
                                return classDeclarationSyntax;
                            }
                        }
                    }
                }
            }
        }

        return null;
    }

    static void Execute(ClassDeclarationSyntax classDeclarationSyntax, SourceProductionContext context)
    {
        var className = classDeclarationSyntax.Identifier.ValueText;
        var namespaceName = GetNamespace(classDeclarationSyntax);

        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sourceBuilder.AppendLine($"namespace {namespaceName}");
            sourceBuilder.AppendLine("{");
        }

        sourceBuilder.AppendLine($"    /// <summary>");
        sourceBuilder.AppendLine($"    /// Compile-time constants for {className} static members");
        sourceBuilder.AppendLine($"    /// </summary>");
        sourceBuilder.AppendLine($"    public static class {className}Constants");
        sourceBuilder.AppendLine("    {");

        // Generate constants for each static field
        foreach (var member in classDeclarationSyntax.Members)
        {
            if (member is FieldDeclarationSyntax fieldDeclaration &&
                fieldDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)))
            {
                foreach (var variable in fieldDeclaration.Declaration.Variables)
                {
                    var fieldName = variable.Identifier.ValueText;

                    sourceBuilder.AppendLine($"        /// <summary>");
                    sourceBuilder.AppendLine($"        /// Constant for {className}.{fieldName}");
                    sourceBuilder.AppendLine($"        /// </summary>");
                    sourceBuilder.AppendLine($"        public const string {fieldName} = \"{fieldName}\";");
                    sourceBuilder.AppendLine();
                }
            }
        }

        sourceBuilder.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sourceBuilder.AppendLine("}");
        }

        context.AddSource($"{className}Constants.g.cs", sourceBuilder.ToString());
    }

    static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var parent = classDeclaration.Parent;
        while (parent != null)
        {
            if (parent is NamespaceDeclarationSyntax namespaceDeclaration)
            {
                return namespaceDeclaration.Name.ToString();
            }
            parent = parent.Parent;
        }
        return string.Empty;
    }
} 